



## Blocking, Non Blocking

https://alwayspr.tistory.com/44

Sync + Blocking I/O

- Spring MVC + RDBMS
- Thread가 해당 작업이 끝날때까지 다른 일을 할 수 없다
- 멀티 Thread라 다른 작업이 가능한거처럼 보일 수 있는데 Context Switching비용이 발생

   

Sync + Non-Blocking I/O

- I/O 요청후 바로 다른 일을 하다가 특정 시간에 준비가 다 되었는지 상태를 확인한다
- 주기적으로 폴링을 해야되는 자원 낭비

   

ASync + Non-Blocking I/O

- I/O 요청후 즉시 리턴, 하지만 데이터가 준비되면 이벤트나 callback을 통해 작업
- Spring WebFlux



**Event-Driven**

Event Handler가 Event를 처리하는 원리

- 무한 반복하면서 Event 발생을 확인하는 쓰레드가 있다. 감지하도록 등록하는게 Listener 처리하는게 Handler

HTTP Request 를 Event로 처리

Spring boot2에서 Reactive Stack과 Servlet Stack 두가지를 지원한다

- Spring WebFlux <-> Spring MVC

- Mongo <-> JDBC



톰캣은 HTTP 요청당 Thread를 생성, Thread pool size를 넘는 요청은 Queue에서 대기

Event driven 은 다수의 요청을 적은 Thread가 처리

MSA에선 수많은 Microservice가 서로를 호출하기에 많은 Network I/O가 발생, 이를 Non Blocking I/O를 통해 개선

WebFlux를 제대로 사용하려면 ASync + Non Blocking I/O를 제대로 구현하려면 모든 I/O 작업이 Non Blocking으로 동작해야됨

트래킹 하기 힘듬 - 낮은 트래픽이라면 구현하기 쉽고 디버깅이 쉬운 기존 방식을 사용하는 것도..





## Kafka



매트릭? 모니터링용 데이터 시스템

로그 모니터링용 데이터 시스템

서비스에 필요한 데이터 시스템

실시간 처리를 위한 키/값 저장소, 사용자의 HTTP 요청



여러 시스템들의 end to end 연결 방식이 가져오는 문제점

- 통합된 전송 영역이 없으니 복잡도의 증가
- 데이터 파이프라인 관리의 어려움, 수많은 다른 종류의 데이터 시스템이 있는데 각각의 개발자마다 다른 방법으로 파이프라인을 만들고 유지



카프카 적용 후

- 카프카가 전사 데이터 파이프라인으로 동작
- 새로운 데이터 시스템이 들어와도 적용 용이
- 실시간 분석
- 백엔드에 따른 포맷, 별도의 앱 개발 없이 카프카에 데이터를 전달하기만 하면 됨

   

> 링크드인 사용자가 프로필을 업데이트 하면 이 정보가 바로 카프카로 전달됩니다. 이 정보를 실시간 스트림으로 처리해서 데이터 웨어하우스에 저장된 회사 정보，위치，기타 속성들을 변경합니다. 그리고 카프카에서 이 데이터의 변경사항을 모니터링하고 있던 검색 인덱스 시스템，소셜 그래프 시스템, 직업 추천을 위한 추천 시스템으로 이동해 처리됩니다. 



프로듀서 컨슈머 모델

- 두 개체가 직접 message를 주고받는게 아니라 중간의 메시징 시스템에 전달
- 컨슈머가 죽어도 메시지는 살아있다
- 확장성 용이
- 정확하게 전달됬는지 확인하기 힘듬, 한단계 거치기 때문에 전달 속도 제한
- 메시징 시스템을 구현하는것도 힘듬(내부 정확성, 내부 프로세스 구현, 성능 issue)



신뢰성 관리는 프로듀서와 컨슈머에게, 부하가 걸리는 교환기 기능을 컨슈머가 만들면서 메시징 시스템 자체의 작업량을 줄이고 이를 성능에 집중

1. 프로듀서가 새로운 메시지를 보내면
2. 카프카에 컨슈머 큐(topic)에 도착해 저장
3. 컨슈머는 서버에 접속하여 새로운 메시지를 가져간다

   

프로듀서는 여러개의 토픽에 메시지를 보낼 수 있고 컨슈머도 여러개의 토픽을 가져올 수 있다 

디스크에 잠시 저장해 둔다

서비스 중단 없이 클러스터 확장이 용이

고성능.. 어떻게?



브로커 : 카프카 애플리케이션이 설치되어 있는 서버 또는 노드

파티션 : 병렬처리가 가능하도록 토픽을 나누고 많은 양의 메시지 처리를 위해 파티션 수를 늘려줄 수 있다













 OLTP?





