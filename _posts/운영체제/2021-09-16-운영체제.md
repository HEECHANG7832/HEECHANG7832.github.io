[TOC]



## 운영체제

**프로세스와 스레드의 차이는 무엇인가요?**

**프로세스**는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 의미합니다. Code, Data, Stack, Heap구조로 되어 있는 독립된 메모리 영역과 ,CPU 시간 등을 할당 받습니다. 기본적으로 메인 스레드를 가지고 있고 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다. 반면

**스레드**는 프로세스 내에서 실행되는 여러 흐름의 단위를 말합니다 프로세스가 할당받은 자원을 사용하며 Stack과 PC레지스터만 따로 받고 Code Data Heap 영역은 공유합니다.



p.s

**자바스레드란**

일반 스레드의 의미이며 JVM이 운영체제 역활을 합니다 자바에는 프로세스가 존재하지 않고 스레드만 존재하며 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록입니다.



**멀티 프로세스**

- 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는것
- 크롬 탭은 탭마다 PID를 가지는 Process로 하나의 탭이 문제가 생겨도 다른 탭에 영향을 주지 않는다
- ContextSwitching과정중 캐쉬 초기화 등이 필요해 오버헤드가 많이 발생하고 프로세스 사이의 통신은 어렵다

**멀티 쓰레드**

- 하나의 응용프로그램을 여러개의 스레드로 구성
- 웹 서버는 대표적인 멀티 스레드 응용 프로그램
- 프로세스 생성하여 자원을 할당하는 시스템 콜이 줄어 자원이 효율적
- 쓰레드 간 ContextSwitching은 빠르고 공유 영역이 있어 통신의 부담이 적다, 동기화 문제가 생김
- 하나의 쓰레드의 문제가 전체 프로세스가 영향을 받음



**ContextSwitching이란**

https://jeong-pro.tistory.com/93

동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다

- PCB의 저장정보

  - 프로세스 상태 : 생성, 준비, 수행, 대기, 중지

  - 프로그램 카운터 : 프로세스가 다음에 실행할 명령어 주소

  - 레지스터 : 누산기, 스택, 색인 레지스터

  - 프로세스 번호

- 인터럽트의 종류 :

  - I/O Request : 입출력 요청
  - Time Slice Expired : CPU 사용시간 만료
  - Fork Child : 자식 프로세스 생성
  - Wait for interrupt : 인터럽트 처리 대기

컨텍스트 스위칭 시 CPU는 아무런 작업을 하지 못한다. 따라서 잦은 컨텍스트 스위칭은 성능 저하를 일으킴.



**PCB란**

**PCB** 란 Process Control Block의 약자로, 프로세스 제어 블록이다. 프로세스에 대한 중요한 정보를 저장하고 있다. 운영체제가 프로세스를 표현한 것이라고도 한다. 프로세스 생성시 만들어지며, 주기억장치에 유지된다. 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. PID, 상태, 다음 명령어 주소 등의 정보가 저장됨.



Reference

https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html



### 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?

멀티 프로그래밍 환경에서 CPU와 같은 한정되고 공동된 자원을 사용할 때 데드락이 발생할 수 있다.
예를 들어 프로세스 A가 자원 1을 사용 중인 상태에서 자원 2를 사용하려고 하지만 프로세스 B가 자원 2를 이미 사용하고 있어 대기중이다. 그런데 프로세스 B가 자원 2 사용을 끝내려면 자원 1이 필요한데, 프로세스 A가 이미 자원 1을 사용하고 있기 때문에 대기해야 한다. 즉 서로의 자원을 쓰고 싶은데 서로가 쓰지를 못하니 무한 대기상태가 걸리는데 이를 데드락, 교착상태라 한다.

**데드락의 발생 조건 4가지(모두 만족해야 함) :**

- 상호 배제 : 한 자원은 한 프로세스에 의해서만 사용됨, 두 개 이상 사용 불가
- 점유 대기 : 프로세스는 자원을 가진 채 다른 자원을 기다릴 수 있음
- 비선점 : 다른 프로세스가 사용 중인 자원을 강제로 가져올 수 없음
- 순환 대기 : 프로세스의 집합에서, 각 프로세스는 순환적으로 다음 프로세스가 필요로 하는 자원을 가지고있다.



### 교착상태의 해결법은 무엇인가요?

- 데드락 해결법 :
  예방 : 4가지 조건 중 하나라도 만족되지 못하게 함
  회피 : 알고리즘을 데드락이 발생하지 않도록 적용
  회복 : 교착상태가 발생하면 그때 해결함
  무시 : 회복과정의 성능저하가 더 심하다면 그냥 무시함



### 뮤텍스와 세마포어에 대해서 설명해 보시오.

https://velog.io/@conatuseus/OS-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4

세마포어나 뮤텍스는 **"여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법"**
으로 정의할 수 있습니다. 즉, **병행 처리를 위한 프로세스 동기화 기법**입니다.

세마포어는 정수 값을 가지는 변수로 볼 수 있습니다. 

**semWait 연산**: 세마포어 값을 감소시킵니다. 만일 값이 음수가 되면 semWait를 호출한 프로세스는 블록됩니다. 음수가 아니면, 프로세스는 계속 수행될 수 있습니다.

- 임계영역에 들어가면서

**semSignal 연산**: 세마포어 값을 증가시킵니다. 만약 값이 양수가 아니면(0이거나 음수면), semWait 연산에 의해 블록된 프로세스들을 깨웁니다.

- 임계영역에 나오면서

뮤텍스는 세마포어와 마찬가지로 **병행 처리를 위한 동기화 기법** 중 하나입니다. 이진 세마포어와 같이 초기값을 1과 0으로 가집니다.



**차이점**

- 세마포어는 공유 자원에 **세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근**할 수 있습니다. 반면에 뮤텍스는 **오직 1개만의 프로세스(또는 쓰레드)만 접근**할 수 있습니다.
- 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있습니다.** 하지만 뮤텍스는 **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 합니다.



https://velog.io/@holim0/Semaphore





### 경쟁 상태란?

경쟁 상태란 두 개 이상의 프로세스 혹은 스레드가 공유 자원을 동시에 사용할 때 그 순서에 따라 결과가 달라지는 문제
은행 잔고를 예제로 들면 은행 잔고라는 공유 데이터를 읽어와서 입금 연산과 출금 연산을 하는데, 동시에 접근해서 연산해버리면 한 쪽 연산이 반영이 안되는 문제



임계 영역을 프로세스들이 같이 쓸 수 있는 전제 조건은 다음과 같다.

- 상호 배제 (Mutal Exculsion) : 프로세스가 크리티컬 섹션에 들어가 있다면, 다른 프로세스는 크리티컬 섹션에 들어갈 수 없다.
- 진행 (Progress) : 크리티컬 섹션에 들어가 있는 프로세스가 없다면 다른 후보 프로세스가 진입할 수 있다.
- 한정된 대기 (Bounded Waiting) : 프로세스가 진입 가능한 횟수에는 제한이 있다(특정한 한 프로세스만 계속 진입하는 것을 방지).



### 프로세스 혹은 스레드의 동기화란 무엇인가요?

프로세스 동기화는 여러 프로세스가 **공유하는 자원의 일관성**을 유지하는 것이다. 가령 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜주어야 한다.

- 자바 문법에서는 한 줄이라 문제가 없어 보이지만, 로우 레벨(어셈블리어)로 내려가면 여러 줄로 구현된다. 
- 세마포는 동기화를 위해 만들어진 소프트웨어로서, 대표적인 **동기화 도구**이다.

https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-8.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1



### 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?

**사용자가 스레드 관련 라이브러리로 구현해 사용하는 스레드를 사용자 수준 스레드라고 한다.**

- 장점
  - 커널에 독립적으로 스케줄링을 할 수 있어 모든 운영체제에 적용할 수 있다. 이식성이 높다.
  - 스케줄링이나 동기화를 위해 커널을 호출하지 않으므로, 커널 영역으로 전환하는 오버헤드가 줄어든다.
  - 커널이 아닌 스레드 라이브러리에서 스레드 스케줄링을 제어하므로, 유연한 스케줄링이 가능하다.

- 단점
  - 하나의 프로세스로부터 할당된 여러개의 스레드들 중, 한 스레드가 대기 상태가 되면, 모든 스레드들을 실행시킬 수 없게 된다.
  - 커널이 스레드 관리에 개입하지 않으므로, 스레드 간 보호에 커널의 보호 방법을 사용할 수 없다. 라이브러리 수준의 보호 방법까지만 사용 가능하다.

**커널 수준 스레드**

커널이 스레드와 관련된 모든 작업을 관리하는 방식이다.

사용자 수준 스레드와 커널 수준 스레드가 1대1로 매핑된다.

커널이 직접 스케줄링하고 실행하기 때문에 커널의 관리 지원을 많이 받을 수 있지만, 그 만큼 오버헤드가 늘어난다.

하지만 커널이 각 스레드들을 개별적으로 관리할 수 있으므로, 동일한 프로세스에서 할당된 여러개의 스레드들 중 한 스레드가 대기상태가 되더라도, 다른 스레드들은 실행시킬 수 있다.

https://helloinyong.tistory.com/293



### CPU 스케줄링이란 무엇인가요?

- 스케줄러란 CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말한다. 그 Queue에는 세 가지가 있다.
  - Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합
  - Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합
  - Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합
- 장기 스케줄러 (잡 스케줄러) : 프로세스가 한꺼번에 많이 올라올 시, 메모리와 디스크 사이에서 메모리에, Ready Queue에 어떤 걸 집어넣을지 결정
- 단기 스케줄러 (CPU 스케줄러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케줄링
- 중기 스케줄러 (Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮김, 동시에 메모리가 많이 올라가는 것을 조절

- CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?
  - 스케줄링 대상은 Ready Queue에 있는 프로세스 대상이다.
    - FCFS (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐
    - SJF (Short Job First) : 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수도 있음(Starvation). 수행시간(CPU Burst Time)은 알지는 못하고 예측만 가능하며, t가 실제시간, r이 예상 시간일때 *r**n*+1=*α**t**n*+(1−*α*)*r**n* (*α*값은 가중치)
    - SRT (Short Remaining Time) : 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 선점형 스케줄링. Starvation과 CPU 수행 시간을 측정할 수 없다는 문제가 있음
    - 우선순위 : 정수로 표현된 우선순위가 더 높은 프로세스에게 할당한다. 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한 대기하는 상태가 있을 수 있음. 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능.
    - Round Robin : 현대적인 CPU 스케줄링으로, 각 프로세스는 동일한 CPU 할당 시간을 갖게 됨. 할당시간 만료시 ready queue 맨 뒤에 가서 줄섬. CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케줄링. 주의할 점은 할당하는 시간(time quantum)이 너무 길다면 FCFS와 다를게 없음. 너무 작다면 잦은 컨텍스트 스위칭이 발생



### 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

- 동기는 어떤 일에 대한 요청과 응답(혹은 입출력)이 **동시에** 이루어져야 하는 것

- 비동기는 어떤 일에 대한 요청과 응답이 동시에 이루어질 필요 없이 **따로** 이루어지는 것.

- 블로킹은 어떤 요청에 대한 응답이 올 때까지 대기 하는 것. 즉 동기를 위해서는 블로킹 되어야 함

- 넌블로킹은 어떤 요청에 대해서 응답을 대기하지 않고 계속 루틴을 수행하는 것.

  

 비동기를 위해서는 넌블로킹 되어야 하지만, 넌블로킹이 비동기는 아니다(포함관계라고 생각하면 될 듯). 예를 들어 넌블로킹이면서, 요청에 대한 응답을 계속해서 요구하는 폴링 방식의 경우, 비동기라 보기는 힘들다. 이벤트 핸들러나 인터럽트를 통해 응답을 받는 것이 비동기 모델.

https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx



### CPU 클럭이란

일반적으로 클럭 속도가 높을수록 CPU 속도가 빠릅니다. 하지만 여기에는 여러 다른 요인도 작용합니다.

CPU는 매초 다양한 프로그램의 많은 명령(연산과 같은 하위 계산)을 처리합니다. 클럭 속도는 CPU가 초당 실행하는 사이클 수를 GHz(기가헤르츠) 단위로 측정합니다

클럭 속도가 3.2GHz인 CPU는 초당 32억 번의 사이클을 실행합니다. (구형 CPU의 속도는 메가헤르츠 또는 초당 수백만 사이클로 측정되었습니다.)

단일 클럭 사이클에서 다수의 명령이 완료되는 경우가 있고, 하나의 명령이 여러 클럭 사이클에 걸쳐 처리되는 경우가 있습니다. 다양한 CPU 설계에 따라 명령을 다르게 처리하므로, 동일한 CPU 브랜드와 세대에서 클럭 속도를 비교하는 것이 가장 좋습니다.

이러한 디지털 신호를 빠르게 처리하는 연산 속도는 CPU마다 다르다. 속도를 나타내는 대표적인 단위는 클럭(Clock)이다. 클럭이란 **1초당 CPU** **내부에서 몇 단계의 작업이 처리되는 지**를 측정하여 주파수 단위인 헤르츠(Hz)로 나타낸 것이다. 즉, 이 클럭 수치가 높을수록 빠른 성능의 CPU라고 볼 수 있다. 예를 들어 인텔 코어(Core) i7 4790K라는 제품의 CPU는 클럭이 4GHz 인데, 이는 1초에 약 40억개의 작업이 처리됨을 의미한다. 



### 패리티 비트(Parity Bit) 오류 검출

패리티 비트는 저장된 데이터의 1bit 오류를 검출하는 코드 방식입니다.

패리티 비트에는 홀수(odd, 기수)방식, 짝수(even, 우수)방식이 있습니다.

홀수 방식의 경우는 데이터의 합이 홀수가 되게 삽입하는 비트가 패리티비트가 되며

짝수 방식의 경우에는 데이터의 합이 짝수가 되게 비트를 삽입합니다.





## 메모리

프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.

### stack 영역

프로그램이 자동으로 사용하는 메모리 영역으로 함수 호출과 관계되는 지역변수와 매개변수가 저장된다. 함수 호출 시 생성되며, 함수가 끝나면 반환된다. stack 사이즈는 각 프로세스마다 할당되지만 프로세스가 메모리에 로드될 때 stack 사이즈가 고정되어 있어 런타임 시 stack 사이즈를 바꿀 수 없다. 명령 실행 시 자동으로 증가 또는 감소하기 때문에 보통 메모리의 마지막 번지를 지정한다.

### heap 영역

필요에 의해 메모리를 동적으로 할당할 때 사용하는 메모리 영역으로 동적 메모리 영역이라고 부른다. C 에서 `malloc()` `calloc()` 등의 함수를 사용하여 메모리 크기를 할당할 수 있으며, 메모리 주소 값에 의해서만 참조되고 사용되는 영역이다.

- 위의 stack과 heap영역은 사실 같은 공간을 공유한다. heap이 메모리의 낮은 주소부터 할당되면 stack은 높은 주소부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 `stack overflow`, `heap overflow` 라고 한다.

### Data 영역 (BSS, GVAR)

프로그램이 실행될 때 생성되고 프로그램이 종료되면 시스템에 반환되며, 전역변수, 정적변수, 배열, 구조체 등이 저장된다. Data 영역은 다시 `BSS` 영역과 `Data(GVAR)` 영역으로 나누어지는데, 초기화된 데이터는 Data 영역에 저장되고, 초기화되지 않은 데이터는 BSS 영역에 저장된다.

### Text (Code) 영역

텍스트 영역은 실행 명령을 포함하는 **코드들이 들어가는 부분**이다.
프로그램을 시작 할 때 컴파일한 프로그램(기계어)이 저장되어 있고, **읽기 전용 영역**이기에 프로세스가 함부로 변경 할 수 없고 변경 시 오류를 발생시킨다.
코드 자체를 구성하는 메모리 영역으로 Hex 파일이나 Bin 파일 메모리이다. 프로그램 명령이 위치하는 곳으로 기계어로 제어되는 메모리 영역이다.

https://kyu9341.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2020/10/04/OS_Process_Structure/



### 메모리 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.



### 페이지와 세그멘테이션에 대해서 설명해 보시오.

**페이징 :**
외부 단편화의 압축 작업을 해소하기 위한 방법론으로, 물리 메모리는 Frame, 논리 메모리는 Page라는 고정 크기의 블록으로 나눈다. 프로세스를 페이지 단위로 나눈 뒤에, 사용하지 않는 영역을 보조기억장치에 적재한다. 이를 페이징 되었다고 하는데, 만약 이 페이징 된 영역에 접근해야 하면 페이징 폴트를 발생시킨 후 메모리에 적재시킨다(요구 페이징). 페이징된 정보는 페이징테이블에 저장된다. 단점으로는 내부 단편화가 발생할 수 있다.

세그멘테이션 :
메모리를 페이지와는 다르게 가변 크기의 세그멘테이션으로 나눈다(물리 메모리 블럭 크기와 다르다). 나누는 시점은 메모리를 사용하게 되는 시점이다. 각 세그멘테이션은 스택, 데이터, 힙, 코드 영역 등으로 나뉘게 된다. 나뉜 세그멘테이션은 시작 주소값과 길이 값이 세그멘테이션 테이블에 저장된다. 자주 사용하면 외부 단편화가 발생할 수 있다.

### 외부 단편화란? 내부 단편화란?

단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간이다. 크게 외부 단편화와 내부 단편화로 나뉜다. 외부 단편화는 프로세스와 프로세스 사이에 발생하는 빈 공간이고, 내부 단편화는 프로세스 안에서 발생하는 빈 공간이다. 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않다.

### First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오.

First Fit : 메모리를 할당할 때, 가장 먼저 발견한 곳에 집어넣음
Best Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 작은 곳에 집어넣음(정렬 필요)
Worst Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 큰 곳에 집어넣음(정렬 필요)
공간 효율성 : Best Fit > First Fit > Worst Fit
시간 효율성 : First Fit > Best Fit = Worst Fit

### 페이지 교체 알고리즘 종류에는 어떤 것들이 있나요?

FIFO (First In First Out) : 말 그대로 먼저 들어온 페이지를 먼저 내보낸다. 간단한 알고리즘이지만, 페이지의 중요도를 따지지 않기 때문에 초기 변수가 담긴 페이지를 내려버리는 등 여러 문제를 초래할 수 있다.

최적 페이지 교체 (Optimal Page Replacement) : 앞으로 가장 사용되지 않을 페이지를 계산하여 교체한다. 다만 모든 프로세스의 계획을 파악하기가 쉽지 않기 때문에, 어떤 페이지를 교체해야 하는가의 알고리즘을 구현할 때 어려움이 있다.

LRU (Last Recently Used) : 가장 나중에 사용된 페이지를 교체한다. FIFO보단 낫고 OPT보단 못하다.

LFU (Least Frequently Used) : 가장 덜 사용된 페이지를 교체한다. 활발한 페이지는 사용이 많이 되었을거라는 가정하에 만든 알고리즘. 초기에 많이 사용되었다가 지금은 사용되지 않는 페이지의 경우 교체가 이루어지지 않는다는 문제가 있다.

MFU (Most Frequently Used) : 가장 많이 사용된 페이지를 교체한다. 가장 적게 사용된 페이지가 최근에 올라오고 계속 사용될 것이라는 가정. 잘 쓰이지 않는다.



### 페이지 폴트 발생시 동작

https://preamtree.tistory.com/21