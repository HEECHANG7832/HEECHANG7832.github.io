# 네트워크

[TOC]



### 네트워크

점과 점이 어떤것에 의해 연결되어서 무언가를 주고 받을 수 있는 것

리소르를 공유할 수 있는 것이 네트워크의 장점

데이터를 주고받음으로써 리소르를 공유

컴퓨터 네트워크는 패킷 교환 방식



라우터 끼리의 포인트 투 포인트네트워크와 허브를 사용한 멀티액세스 네트워크가 있다

좁은 범위에서 만든 네트워크가 LAN

넓은 규모로 통신사업자로부터 케이블을 빌려서 만든게 WAN

세계 최대 규모 WAN은 인터넷



**허브**

허브는 수신한 신호에 대해서 어떤 제어도 하지 않는다

수신한 포트 이외의 모든 포트에 수신한 신호를 송신 - 플러딩

허브로 연결한 컴퓨터는 같은 충돌 도메인에 존재



**2계층의 범위 - Ethernet**

라우터와 라우터 사이, 멀티액세스 네트워크에서 허브에 연결되어있는 범위

유니캐스트

멀티캐스트

브로드캐스트

컴퓨터는 유일한 유니캐스트 주소를 가질 필요가 있다 - MAC주소

**이더넷 프레임**

수신처 MAC 주소, 송신처 MAC주소, 타입, (헤더)  페이로드(3계층 PDU), FCS(에러 체크용 트레일러)

수신한 프레임의 수신처 MAC주소를 보고 자기에게 온게 아니면 파기한다

CSMA/CD 액세스 제어(반 이중 통신)

- 가능한 충돌이 발생하지 않게 하기 위해 타이밍을 비켜나게 함



**허브 대신에 사용하는 스위치**

MAC 주소 필터링, 버퍼링

포트에 연결되어 있는 컴퓨터의 MAC주소를 기억 - 어드레스 테이블

충돌할 것 같은 프레임은 버퍼에 일시적 저장한다 - 버퍼링

버퍼가 초과할거 같으면 송신측에  PAUSE 프레임 전송

스위치를 사용하면 전이중 통신이 가능 - 전이중 이더넷



인터넷 규모급이 되면 네트워크에 연결된 컴퓨터 수가 많아져서 스위치로는 구성하기 힘들다(번번히 브로드캐스트 되야 함으로)

따라서 라우터를 넘어서는 브로드캐스트는 송신되지 않는다



네트워크와 네트워크 사이 전송

### 3계층

IP를 사용 - IP 헤더, 페이로드

인터넷 작업을 수행 - 어드레싱, 라우팅

논리주소 IP를 사용 - 소속된 네트워크 에서만 유일하면 된다

클래스리스 어드레싱, 슈퍼넷



**DHCP** - 송신처의 IP 획득

할당할 IP 주소를 관리하고, 실제로 할당 작업을 수행하는 서버, 클라이언트로 이루어짐

설정된 IP 주소 풀에서 클라이언트에게 유일한 것이 되게 할당

DHCP 메시지 - 모든 메시지를 브로드케스트

DISCOVER 메시지를 브로드케스트

OFFER 서버는 IP풀에서 선택해서 제안

REQUEST 제안 받은 IP주소가 문제 없으면 REQEUST를 브로드캐스트

ACK 승인



수신처 MAC주소는 수신처의 IP주소가 결정된 뒤에 

**ARP**

IP를 아는 상태에서 해당 수신처 IP에게 MAC주소를 알려달라고 요청한다 받은 MAC주소를 ARP 테이블에 기재

브로드캐스트로 네트워크 모든 컴퓨터에 송신



**DNS** 수신처의 IP 획득

해당 네트워크의 DNS에게 IP를 물어본다



현재 컴퓨터 네트워크에 설정된 라우터를 디폴트 게이트웨이 라고 한다



**라우팅**

데이터그램의 수신처 IP를 근거로 다음에 송신할 라우터를 결정

라우터는 여러 네트워크의 인터페이스를 가지고 있다

라우팅 테이블 - 수신처 네트워크까지의 거리, 다음에 도달하는 라우터, 그 라우터에 연결된 자신의 인터페이스

수신처 IP와 다음 라우터 IP 비트가 가장 일치하는 것을 선택



**다른 네트워크에 있는 경우 ARP는?**

일단 호스트는 디폴트 게이트웨이로 데이터를 보내서 다른 네트워크로 전성

컴퓨터는 다른 네트워크에 데이터를 송신할 때 디폴트 게이트웨이로 ARP를 수행

컴퓨터의 디폴트 게이트웨이 IP는 미리 설정 - DHCP할때 서브넷 마스크와 IP 그리고 디폴트 게이트웨이를 받는다



**라우팅 프로토콜**

중복성 유지를 위해 동적 라우팅, 근접한 라우터 간의 네트워크 정보를 교환하기 위해 라우팅 프로토콜 사용

AS(자율화 시스템) 간 라우팅 - EGP

AS 내부 라우팅 - IGP



**메트릭**

중계하는 라우터의 수, 회선의 속도, 정체상태, 에러 발생률 등 최적의 경로를 결정할때 판단 기준



RIP

경로갱신정보를 주고받을때 라우팅 테이블을 그대로 교환

일정 횟수 수신이 없으면 장애라고 판단

RIP 는 메트릭의 홉 수를 사용

이미 테이블에 존재하는 네트워크에 대해서 메트릭이 작으면 그쪽을 테이블에 기재



**ICMP**

인터넷 제어 메시지 프로토콜 - 에러 보고 프로토콜

Query 상태를 조사하기 위한 메세지, Error 에러를 통지하기 위한 메세지

IP의 데이터그램 TTL은 라우터를 경유할 때마다 1씩 줄어들고 0이 되면 해당 데이터그램은 파기

타입 3은 수신처에 도달하지 않는 이유 통지

- Echo : 송신측이 보낸 요청을 그대로 돌려받는다 ping
- Time Exceeded : 데이터 그램이 파기될때 해당 라우터에서 송신처로 보낸다, traceroute에 사용됨 TTL을 짧게 보내서 ICMP를 고의로 수신한다





### 4계층

흐름제어 - 처리 능력을 넘어선 정보를 받을때 넘치는 것을 방지한다

확인 응답이 없는 경우 재 전송한다

데이터를 주고받는건 애플리케이션, 어느 애플리케이션이 수신할지 포트 번호로 결정



**TCP**

TCP 헤더의 크기는 기본적으로 20옥텟 헤더 6비트, 제어비트

TCP는 애플리케이션으로 부터 받은 데이터를 세그먼트로 캡슐화 한다, 캡슐화 할때 한 개의 데이터를 MSS로 분할하는데 각 세그먼트를 번호를 부여하고 이를 시퀀스 라고 한다 1옥텟(8비트) 마다 번호를 달성한다 1000옥텟인경우 3000바이트는 1, 1001, 2001 맨 선두의 번호로 시퀀스로 정한다

브로드캐스트를 사용할 수 없다



**윈도우 제어**

TCP는 세그먼트를 수신하면 수신한 것을 송신처에게 전달 - 확인응답

확인응답은 다음에 받고 싶은 선두 옥텟 번호

이걸 한번씩 주고받을 순 없으니 복수의 세그먼트전송 -> 확인응답 형태로 한다

확인응답에 윈도우 사이즈를 포함시켜 송신측은 이에 맞춰서 적절한 분량만 보낸다



**UDP**

확인응답을 기다리는 시간이 치명적, 따라서 UDP는 포트번호 외에 다른 항목이 존재하지 않는다

고속성이나 실시간 송수신이 필요한 애플리케이션 등에 사용

브로드캐스트가 필요한 애플리케이션도 UDP를 사용



**NAT 네트워크 주소 변환**

IP주소는 고갈되고 있기 때문에 글로벌 IP를 사용할 수 없다

내부 네트워크에는 사설 IP 할당

단, 보유하고 있는 글로벌 IP 주소 만큼만 동시접속할 수 있다



**NAPT**

하나의 글로벌 IP 주소로 복수의 컴퓨터를 접속 가능하게

IP주소 뿐만 아니라 포트 번호도 같이 변환

NAT테이블에 없는 포트면 변환되지 않기 때문에 내부 네트워크에 침임할 수 없다

FTP는 데이터 부분에도 송신처의 IP 주소와 포트 번호가 기술되는데 NAT에서는 IP 헤더 이외의 부분은 변환되지 않기 때문







### OSI 7계층

https://shlee0882.tistory.com/110

- 계층을 나눈 이유는 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문이다.

- 통신 접속에서 완료까지 과정을 7단계로 정의한 국제 통신 표준 규약. 물데넷트세프어

  

- 물리 계층 - 기계적 전자적 통신, 전파, 광섬유 등

- 데이터 링크 계층 - 정보의 오류와 흐름을 관리, 맥 주소, 브리지 스위치, 이더넷

  - 장치 간 신호를 전달하는 물리계층을 이용하여 데이터 전송, 주소 할당, 오류 감지기능
  - MAC 기능 담당
    - 물리적으로 연결된 노드간 프레임 전송에 사용됨
    - LAN 카드에 하드웨어적 정보

- 네트워크 계층 - 목적지까지 전달하는 라우팅 기능, 라우팅, 계층적 논리 주소 IP사용

  - 패킷을 송신에서 수신으로, 전송계층으로부터 세그먼트를 받아서 캠슐화하고 데이터 링크 계층으로 전달

- 전송 계층 - 양 끝단이 신뢰성 있는 데이터를 주고받을 수 있게 시퀀스 넘버 기반 오류제어, 패킷이 유효한지 확인하고 재전송 TCP

  - 추상 포트 간 데이터 교환 담당
  - 포트번호, 두 개의 프로세스 간 메시지 전달에 사용

- 세션 계층 - 양 끝단 응용 프로세스가 통신을 관리하기 위한 방법, duplex, full duplex, TCP/IP 세션을 만들고 없애는 책임, SSH

- 표현 계층 - 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어준다. 해당 데이터가 텍스트인지, 그림인지, GIF, JPG 등 구분, JPEG

- 응용 계층 - HTTP, FTP Telnet등 브라우저나 메일 프로그램은 이들 프로토콜을 쉽게 사용하도록 도와줌



### TCP/IP 4계층에 대해서 설명해주세요.

- TCP/IP 4계층 : 통신에 실제 사용되는 계층(프로토콜 스택). 

- 왜 쓰는가? -통신이 일어나는 과정을 단계별로 파악하여, 문제 발생시 트러블슈팅이 용이하다. 즉 분할 정복이 가능하다.

  

  **1계층 네트워크 액세스 계층(Network Access Layer or Network Interface Layer)**

  OSI 7계층의 물리계층과 데이터 링크 계층에 해당한다.

  물리적인 주소로 MAC을 사용한다.

  LAN, 패킷망, 등에 사용된다.

   

  **2계층 인터넷 계층(Internet Layer)**

  OSI 7계층의 네트워크 계층에 해당한다. 

  통신 노드 간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당한다.

  프로토콜 – IP, ARP, RARP

  

  **3계층 전송 계층(Transport Layer)**

  OSI 7계층의 전송 계층에 해당한다.

  통신 노드 간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당한다.

  프로토콜 – TCP, UDP

   

  **4계층 응용 계층(Application Layer)**

  OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당한다.

  TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다.

  프로토콜 – FTP, HTTP, SSH

  

### DNS가 무엇인가요?

-  DNS 서비스는 전 세계에 배포된 서비스로서, www.example.com과 같이 사람이 읽을 수 있는 이름을 192.0.2.1과 같은 숫자 IP 주소로 변환하여 컴퓨터가 서로 통신할 수 있도록 합니다. 
-  DNS 서버는 이름에 대한 요청을 IP 주소로 변환하여 최종 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 어떤 서버에 연결할 것인지를 제어합니다. 이 요청을 **쿼리**라고 부릅니다.

### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.

1. 웹 브라우저에 www.naver.com을 입력하면 먼저 Local DNS에게 "www.naver.com"이라는 hostname"에 대한 IP 주소를 질의하여 Local DNS에 없으면 다른 DNS name 서버 정보를 받음(Root DNS 정보 전달 받음)

2. Root DNS 서버에 "www.naver.com" 질의

3. Root DNS 서버로 부터 "com 도메인"을 관리하는 TLD (Top-Level Domain) 이름 서버 정보 전달 받음

4. TLD에 "www.naver.com" 질의

5. TLD에서 "name.com" 관리하는 DNS 정보 전달

6. "naver.com" 도메인을 관리하는 DNS 서버에 "www.naver.com" 호스트네임에 대한 IP 주소 질의

7. Local DNS 서버에게 "응! www.naver.com에 대한 IP 주소는 222.122.195.6 응답 

8. Local DNS는 www.naver.com에 대한 IP 주소를 캐싱을 하고 IP 주소 정보 전달 

 

**Recursive Query** : Local DNS 서버가 여러 DNS 서버를 차례대로 (Root DNS 서버 -> com DNS 서버 -> naver.com DNS 서버) 질의해서 답을 찾아가는 과정

https://www.cloudflare.com/ko-kr/learning/dns/what-is-dns/





### TCP와 UDP의 차이에 대해서 설명해 주세요.

- TCP는 **흐름제어**, **오류제어**를 통한 연결 지향성, 순서 중요함, 오류시 재전송. **전이중과 점대점**(각 연결이 정확히 2개의 종단점을 가지고 있음) 방식.
  UDP는 비연결형 프로토콜, 상대방이 받든지 말든지 그냥 보낸다. 손상된 세그먼트에 대해 재전송하지 않는다. 만약 클라이언트 timeout이 발생하면 다시 보내면 그만이다.

### TCP 헤더에 대해서 설명해 주세요.

**• Source Port/Destination Port(송신 포트/수신 포트) :** TCP로 연결되는 가상 회선 양단의 송수신 프로세스에 할당된 네트워크 포트 주소다. 인터넷 환경에서는 통신을 원하는 프로세스가 실행되는 호스트 주소와 호스트 내부에서 다른 프로세스와 구분할 수 있는 프로세스 전용의 고유 주소가 필요하다. 호스트 주소는 IP [프로토콜](http://terms.naver.com/entry.nhn?docId=2271799&ref=y)에서 정의된 호스트의 IP 주소를 사용해 구분할 수 있다. 프로세스에 할당되는 네트워크 자원을 **포트(Port)**라고 하는데, 포트를 구분하기 위한 고유 주소가 **[포트 번호](http://terms.naver.com/entry.nhn?docId=2271915&ref=y)**다. 포트 번호는 TCP와 UDP가 별도의 주소 공간을 갖기 때문에 같은 번호를 사용할 수 있다.

**• Sequence Number(**[**순서 번호**](http://terms.naver.com/entry.nhn?docId=2271842&ref=y)**) :** 송신자가 지정하는 순서 번호다. 세그먼트 전송 과정에서 전송되는 바이트 수를 기준으로 증가한다. 즉, TCP에서는 전송 데이터의 각 바이트마다 순서 번호가 존재한다. 크기가 32비트인 필드로 표시할 수 있고 최대 범위가 232개 가능해 크기가 충분히 크므로 순서 번호가 쉽게 중복되지 않는다. 송신자가 최초 데이터를 전송할 때는 임의의 순서 번호를 선택해 전송한다. 이는 전송 연결이 예기치 않은 이유로 끊어졌을 때 순서 번호가 혼선되는 것을 방지하기 위함이다.

**• Acknowledgement Number(응답 번호) :** 수신 프로세스가 제대로 수신한 바이트의 수를 응답하기 위해 사용한다. 필드 값은 ACK 플래그 비트가 지정된 경우에만 유효하며, 다음에 수신을 기대하는 데이터의 순서 번호를 표시해야 한다. ACK 응답을 받은 송신 프로세스는 Acknowledgement Number-1까지의 모든 데이터가 올바로 전송되었음을 확인할 수 있다. 연결 설정이나 연결 해제처럼 데이터 세그먼트가 없는 경우에도 순서 번호가 1씩 증가한다.

 **Data Offset(데이터 옵셋) :** TCP 세그먼트가 시작되는 위치를 기준으로 데이터의 시작 위치를 나타내므로 TCP 헤더의 크기가 된다. 32비트 워드 단위로 표시된다.

**• Reserved(예약) :** 예약 필드다.

**• Window(윈도우) :** [슬라이딩 윈도우 프로토콜](http://terms.naver.com/entry.nhn?docId=2271872&ref=y)에서 수신 윈도우의 버퍼 크기를 지정하려고 사용하며, 수신 프로세스가 수신할 수 있는 바이트의 수를 표시한다. 수신자의 버퍼 용량 초과 등으로 인해 데이터를 더는 수신할 수 없으면 Window 필드 값을 0으로 지정한다. 이 경우에 송신 프로세스는 데이터를 더 전송하면 안 된다.

**• Checksum(체크섬) :** TCP 세그먼트에 포함되는 프로토콜 헤더와 데이터 모두에 대한 변형 오류를 검출하려고 사용한다. IP 프로토콜에서 사용하는 [오류 검출](http://terms.naver.com/entry.nhn?docId=2271848&ref=y) 알고리즘을 사용한다.

**• Urgent Pointer(긴급 포인터) :** 긴급 데이터를 처리하기 위한 것으로, URG 플래그 비트가 지정된 경우에만 유효하다. 이 필드를 사용해 송신 프로세스가 긴급히 처리하려는 데이터를 전송할 수 있다. 예를 들어, Sequence Number = 2,000, Urgent Pointer = 100으로 지정한 패킷을 전송한다면 순서 번호 2,000번~2,099번의 데이터는 긴급 데이터로 전송되고 2,100번 이후는 다시 정상 데이터로 전송된다.

TCP 헤더의 플래그 비트

TCP 헤더에는 플래그 비트가 6개 정의되어 있다. 필드 값이 1이면 다음과 같이 각 플래그에 해당하는 의미를 갖는다.

**• URG :** Urgent Pointer 필드가 유효한지를 나타낸다. 긴급 데이터를 전송하기 위해 사용한다.

**• ACK :** Acknowledgment Number 필드가 유효한지를 나타낸다. 정상적인 [피기배킹](http://terms.naver.com/entry.nhn?docId=2271875&ref=y) 방식의 양방향 통신 환경에서, 양단 프로세스가 쉬지 않고 데이터를 전송한다고 가정하면 최초 연결 설정 과정에서 전송되는 첫 번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트가 1로 지정된다고 생각할 수 있다.

**• PSH :** 현재 세그먼트에 포함된 데이터를 [상위 계층](http://terms.naver.com/entry.nhn?docId=2271935&ref=y)에 즉시 전달하도록 지시할 때 사용한다. 수신자에게서 PSH 세그먼트에 대한 응답 [프레임](http://terms.naver.com/entry.nhn?docId=2271844&ref=y)이 도착하면, 프레임의 Acknowledgement Number 필드에 표시한 숫자까지의 모든 데이터가 상대 프로세스의 상위 계층에 전달되었음을 의미한다.

**• RST :** 연결의 리셋이나 유효하지 않은 세그먼트에 대한 응답용으로 사용한다. 송신자가 전송을 마쳤으나 수신자에게 아직 도착하지 못한 세그먼트, 혹은 수신자가 아직 긍정 응답하지 않은 세그먼트는 연결이 재설정되었을 때 반드시 재전송되어야 한다.

**• SYN :** 연결 설정 요구를 의미하는 플래그 비트므로 가상 회선 연결을 설정하는 과정에서 사용된다.

**• FIN :** 한쪽 프로세서에서 더는 전송할 데이터가 없어 연결을 종료하고 싶다는 의사 표시를 상대방에게 알리는 데 사용한다. 현재 전송 과정에 있는 데이터는 계속 처리할 수 있으며, 상대편 프로세스의 데이터 전송에 장애가 발생하지 않는다. 따라서 연결 해제는 양쪽 프로세스 모두가 FIN 플래그를 전송해야 완료된다.

https://m.blog.naver.com/PostView.nhn?blogId=shs6903&logNo=220481726984&proxyReferer=https:%2F%2Fwww.google.com%2F

https://evan-moon.github.io/2019/11/10/header-of-tcp/

https://goodgid.github.io/Error-Flow-Control/



Q: 전송 중간에 패킷이 쥐도새도 모르게 사라지거나 훼손되면 어떡해요?
A: **그럼 그 패킷만 다시 보내라고 해!(ARQ)**

go back n ARQ, Selective ARQ

Q: 송신 측이 패킷을 쪼갠 순서를 알아야 수신 측이 재조립할 수 있겠는데요?
A: **그럼 순서번호를 패킷이랑 같이 보내!(시퀀스 번호)**

Q: 수신 측이 처리할 수 있는 속도보다 송신 측이 패킷을 빠르게 보내버리면 어떡하죠?
A: **그럼 수신 측이 처리할 수 있는 양을 송신 측에 알려주고 그 만큼만 보내라고 해! (슬라이딩 윈도우)**



### MTU가 무엇인가요?

```
1. MTU (Maximum Transmission Unit)

  ㅇ 어떤 데이터링크에서 하나의 프레임 또는 패킷에 담아 운반 가능한 최대 크기
     - 상위 계층(IP 등)의 데이터(헤더 포함된 전체 싸이즈)의 수용 가능한 크기

  ㅇ 따라서, 상위 계층 프로토콜은 하위 계층인 데이터링크에서의 MTU에 맞추어야 하므로,
     - IP 단편화 등을 시행해야 만 함
```



### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요.

**3-way handshake 란**

TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정



A -> B: SYN 접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN) SEQ 100

송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.

PORT 상태 - B: LISTEN, A: CLOSED



B -> A: SYN(300) + ACK(101)

접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)

수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.

PORT 상태 - B: SYN_RCV, A: CLOSED



A -> B: ACK(301)

PORT 상태 - B: SYN_RCV, A: ESTABLISHED

마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)

이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.

PORT 상태 - B: ESTABLISHED, A: ESTABLISHED



**4-way handshake 란**

TCP의 연결을 해제(Connection Termination) 하는 과정

A -> B: FIN SEQ 100 ACK 300
프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지

B -> A: ACK SEQ 300 ACK 101
프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다. (이 상태가 TIME_WAIT 상태)
수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.

B -> A: FIN SEQ 101 ACK 300
프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송

A -> B: ACK ACK 301
프로세스 A는 확인했다는 메시지를 전송



### HTTP 프로토콜에 대해서 아는대로 말해주세요

- 애플리케이션 레벨의 프로토콜로 **TCP/IP위에서 작동**한다.
- HTTP는 **어떤 종류의 데이터든지 전송**할 수 있도록 설계돼 있다. 
- HTTP로 보낼 수 있는 데이터는 **HTML문서, 이미지, 동영상, 오디오, 텍스트 문서** 등 여러종류가 있다.
- 하이퍼텍스트 기반으로(Hypertext) 데이터를 전송하겠다(Transfer) = **링크기반으로 데이터에 접속**하겠다는 의미이다.
- 클라이언트에서 요청(request)를 보내면 서버는 요청을 처리해서 응답(response)한다.
- HTTP는 Connectionless 방식으로 작동한다. 
- **서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다.** 

**장점 :** 

불특정 다수를 대상으로 하는 서비스에 적합한 방식이다. 

수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다.

**단점 :** 

연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없다. 

이러한 HTTP의 특징을 **stateless**라고 하는데, Connectionless 로 부터 파생되는 특징이라고 할 수 있다. 

클라이언트의 이전 상태 정보를 알 수 없게 되면, 웹 서비스를 하는데 당장에 문제가 생긴다. 

클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없다. HTTP는 cookie를 이용해서 이 문제를 해결하고 있다.

클라이언트 소프트웨어(IE, Chrome, Firefox, Safari ...)는 URI를 이용하여 자원의 위치를 찾는다.

**HTTP는 전송 프로토콜이고, URI는 자원의 위치를 알려주기 위한 프로토콜**이다. 

**1.4 Method(메서드)**

메서드는 요청의 종류를 서버에게 알려주기 위해서 사용한다.  

GET : 정보를 요청하기 위해서 사용한다. (SELECT)

POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)

PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)

DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)

https://shlee0882.tistory.com/107.

https://mangkyu.tistory.com/98



### HTTP와 HTTPS 의 차이는 무엇인가요?

**HTTP + SSL = HTTPS**

HTTP는 평문 통신이다. TCP/IP 특성상 도청이 가능하며, 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 가령 나는 IP가 A인 사람한테 보내고 싶은데, 악의적인 해커가 내가 IP A요 하고 말해도 검증할 방법이 없다는 것. 또한 완전성을 증명할 수 없기 때문에 변조가 가능하다. 보안 방법은 통신 자체를 암호화(SSL, TLS)하거나, 콘텐츠를 자체를(HTTP 메시지 컨텐츠를) 암호화 하는 것이다. 도청이 가능한 문제, 사용자를 확인할 수 없다는 문제, 정확성을 보장할 수 없다는 문제를 모두 해결할 방안으로 나온 것이 HTTPS이다.

HTTPS는 새로운 프로토콜이 아닌, HTTP에서 SSL 개념을 더한 프로토콜이다. 기존 HTTP는 TCP와 직접 통신했지만, HTTPS는 HTTP와 TCP 사이에 SSL, TLS가 끼워져 있는 것이다. HTTP는 SSL과 통신하고, SSL은 TCP와 통신하게 된다.

SSL의 원리를 간략하게 설명하면, 대칭키와 공개키 방식 두 암호화 방식을 사용하는데, 먼저 클라이언트가 서버에게 HELLO 메세지를 보내면, 서버가 클라이언트에게 HELLO 메세지를 보내면서, 서버 암호화 된 인증서와 랜덤 데이터를 넘겨주게 된다. HELLO 과정에서 어떤 암호화 프로토콜을 사용할 것인지 협상한다. 클라이언트는 받은 인증서를 CA리스트에서 조회 후 CA 공개키를 사용하여 인증서를 복호화한다. 복호화에 성공 했다면 이 서버는 신뢰할 수 있는 서버이다. 서버가 보낸 랜덤 데이터와 클라이언트의 랜덤 데이터를 조합해서 대칭키를 생성한다. 서버로부터 받은 공개키(인증서)를 사용하여 대칭키를 암호화 후에, 서버에게 보내게 된다. 서버는 암호화된 대칭키를 받고, 비밀키로 복호화 함으로써, 서버와 클라이언트가 서로 대칭키를 가지게 된다. 이 대칭키로 통신을 암호화한다.

https://aws-hyoh.tistory.com/entry/HTTPS-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2Key%EA%B0%80-%EC%9E%88%EC%96%B4%EC%95%BC-%EB%AC%B8%EC%9D%84-%EC%97%B4-%EC%88%98-%EC%9E%88%EB%8B%A4?category=768734



### 비대칭키 RSA

1. 두 소수 p, q를 준비합니다.

2. p와 q의 곱인 N 값을 계산합니다.

3. 1 < e < (p-1)*(q-1)이고, (p-1)*(q-1)와 서로소인 공개키 e를 생성합니다.

4. ( d * e ) mod (p-1)*(q-1) = 1 이고 0 <= d <= N 인 d를 구합니다.

생성된 값들 중 N과 e는 공개키로, d는 비밀키로 사용됩니다.

https://dingue.tistory.com/15



A의 공개키를 이용하여 암호화된 데이터는 A의 개인키로만 복호화가 가능하다.

A의 개인키를 이용하여 암호화된 데이터는 A의 공개키로만 복호화가 가능하다.



### HTTPS가 동작하는 방식에 대해서 설명해 주세요.

1. 먼저 클라이언트에서 서버에 ClientHello 메시지를 보낸다. 여기에는 클라이언트에서 가능한 TLS 버전, 서버 도메인, 세션 식별자, 암호 설정 등의 정보가 포함된다.
2. 클라이언트의 메시지를 받은 서버는 ServerHello 메시지를 클라이언트에게 보낸다. 여기에는 ClientHello 메시지의 정보 중 서버에서 사용하기로 선택한 TLS 버전, 세션 식별자, 암호 설정 등의 정보가 포함된다.
3. 서버가 클라이언트에 Certificate 메시지를 보낸다. 여기에는 서버의 인증서가 들어간다. 이 인증서는 별도의 인증 기관에서 발급받은 것이며, 서버가 신뢰할 수 있는 자임을 인증한다. 전송이 끝나면 ServerHelloDone 메시지를 보내 끝났음을 알린다.
4. 클라이언트는 서버에서 받은 인증서를 검증한다. 인증서의 유효 기간이 만료되지 않았는지, 그 인증서가 해당 서버에게 발급된 인증서가 맞는지 등을 확인한다. 인증서를 신뢰할 수 있다고 판단하였다면 다음 단계로 넘어간다.
5. 클라이언트는 임의의 pre-master secret[[1\]](https://namu.wiki/w/TLS#fn-1)을 생성한 뒤, 서버가 보낸 인증서에 포함된 공개 키를 사용해 암호화한다. 이렇게 암호화된 pre-master secret을 ClientKeyExchange 메시지에 포함시켜 서버에 전송한다.[[2\]](https://namu.wiki/w/TLS#fn-2)
6. 서버는 전송받은 정보를 복호화하여 pre-master secret을 알아낸 뒤, 이 정보를 사용해 master secret을 생성한다. 그 뒤 master secret에서 세션 키를 생성해내며, 이 세션 키는 앞으로 서버와 클라이언트 간의 통신을 암호화하는데 사용될 것이다. 물론 클라이언트 역시 자신이 만들어낸 pre-master secret을 알고 있으므로, 같은 과정을 거쳐 세션 키를 스스로 만들 수 있다.
7. 이제 서버와 클라이언트는 각자 동일한 세션 키를 가지고 있으며, 이 키를 사용해 [대칭키 암호](https://namu.wiki/w/대칭키 암호)를 사용하는 통신을 할 수 있다. 따라서 우선 서로에게 ChangeCipherSpec 메시지를 보내 앞으로의 모든 통신 내용은 세션 키를 사용해 암호화해 보낼 것을 알려준 뒤, Finished 메시지를 보내 각자의 핸드셰이킹 과정이 끝났음을 알린다.
8. 이제 서버와 클라이언트 간에 보안 통신이 구성된다.

https://namu.wiki/w/TLS

### HTTP 1.0과 1.1의 차이는 무엇인가요?

https://withbundo.blogspot.com/2021/02/http-http-10-http-11.html

### HTTP2와 그 특징에 대해서 설명해 주세요.

https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC

### HTTP 헤더의 구조에 대해서 설명해 주세요.

일반 헤더

- 요청 및 응답 메시지 모두에서 사용 가능한 일반 목적의 헤더 항목
- Date, Connection(Keep-Alive), Cache-Control(쿠키/캐시 관련), Pragma, Trailer

엔티티 관련 헤더

- 요청, 및 응답 메시지에 모두 사용 가능한 Entity에 대한 설명
  - HTTP 메시지 내 포함된 개체에 대한 구체적인 미디어 타입 설명
  - Content-Type, Content-Language, Content-Encoding ...
  - Location 리다이렉트 된 때에 이동된 주소, 새로 생성된 주소를 명시

요청 헤더

- HTTP 요청 메시지에만 나타남
- Host 호스트명 및 포트번호 (필수) User-Agent (클라이언트 소프트웨어) Cookie , Origin 서버로 POST 요청을 보낼 때 요청이 어느 주소에서 시작되었는지 여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러

응답 헤더

- 특정 유형의 HTTP 요청이나 특정 HTTP 헤더를 수신했을때
- Server(서버 소프트웨어 정보), Set-Cookie(서버측에서 클라이언트에게 세션 쿠키 정보를 설정)
- Expires, Age, Allow

https://gmlwjd9405.github.io/2019/01/28/http-header-types.html



### keep-alive 헤더에 대해서 설명해 주세요.

Response Header

HTTP/1.1 200 OK **Connection: Keep-Alive**

Content-Encoding: gzip 

Content-Type: text/html;

charset=utf-8

Date: Thu, 11 Aug 2016 15:23:13 GMT 

**Keep-Alive: timeout=5, max=1000** 

Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT Server: Apache  (body)

 

먼저 사용 예는 위와 같습니다. 

HTTP 는 TCP 위에서(기반으로) 동작을 합니다. TCP가 전송이 끝나면 연결이 끊어지듯이 HTTP도 서로 전송이 끝나면 끊어집니다. 그런데 매번 이렇게 똑같은 주소로 요청을 할 때마다 새로운 연결을 설정하고 끊어야 한다면.. 자원이 낭비됩니다.

이런 문제를 막고자 Keep-Alive가 생겼습니다. 말 그대로.. '연결을 계속 유지해라'라는 의미를 가지고 있습니다.

최소 특정 시간동안(timeout) 최대 요청 request(max)의 수를 알려줄 수 있습니다.

 

위의 예시 코드를 본다면.. 최소 5초동안 최대 1000번의 요청을 할 경우에는 http connection이 끊어지지 않을 것으로 보입니다. 와이어 샤크로 패킷을 보면 정확하겠네요. 아래의 참고글에 자세한 설명이 있는 글이 있습니다.

역사가 좀 있네요. 아쉽게도? http 표준은 아닌 것 같은데 ㅎㅎ HTTP 1.1부터는 기본적으로 Keep-Alive로 동작한다고 합니다.

Keep-Alive가 DDOS의 아주 특별한 경우에.. 예방책으로 쓸 수는 있는 것 같으나 좋은 방법은 아닌가 봅니다.



### HTTP GET과 POST의 차이는 무엇인가요?

- GET 요청은 멱등이며, POST는 멱등이 아니다.

- GET 은 클라이언트에서 서버로 어떠한 리소스로 부터 정보를 요청하기 위해 사용되는 메서드이다. GET 요청은 중요한 정보를 다루면 안된다. ( 보안 )

  : GET 요청은 **파라미터에 다 노출되어 버리기** 때문에 최소한의 보안 의식이라 생각하자.

- POST는 클라이언트에서 서버로 **리소스를 생성하거나 업데이트**하기 위해 데이터를 보낼 때 사용 되는 메서드다. 예를들면 게시판에 **게시글을 작성하는 작업** 등을 할 때 사용할 된다.

- POST 요청은 캐시되지 않는다.

  POST 요청은 브라우저 히스토리에 남지 않는다.

  POST 요청은 북마크 되지 않는다.

  POST 요청은 데이터 길이에 제한이 없다.

https://noahlogs.tistory.com/35



### 쿠키와 세션에 대해서 설명해 주세요.

- 저장 위치
  - 쿠키 : 클라이언트
  - 세션 : 서버
- 보안
  - 쿠키 : 클라이언트에 저장되므로 **보안에 취약**하다.
  - 세션 : **쿠키를 이용해 Session ID만 저장**하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
- 라이프사이클
  - 쿠키 : 만료시간에 따라 **브라우저를 종료해도 계속해서 남아** 있을 수 있다.
  - 세션 : 만료시간을 정할 수 있지만 **브라우저가 종료되면 만료시간에 상관없이 삭제**된다.
- 속도
  - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 **빠르다.**
  - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 **느리다.**



**쿠키의 동작 순서**

1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)

2. 웹 서버는 쿠키를 생성한다.

3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때,
   같이 클라이언트에게 돌려준다.

4. 넘겨 받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장)
   다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.

5. 동일 사이트 재방문시 클라이언트의 PC에 해당 쿠키가 있는 경우,
   요청 페이지와 함께 쿠키를 전송한다.

   

**사용 예시**

1. 방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크



**세션의 동작 순서**

1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)

2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,
   클라이언트가 해당 session-id를 보냈는지 확인한다.

3. session-id가 존재하지 않는다면,
   서버는 session-id를 생성해 클라이언트에게 돌려준다.

4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.
   쿠키 이름 : JSESSIONID

5. 클라이언트는 재접속 시,
   이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달

   

**사용 예시**

- 화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

https://doooyeon.github.io/2018/09/10/cookie-and-session.html





## 웹

### 웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요.

사용자가 웹 브라우저에서 http://www.naver.com을 입력

웹 브라우저는 DNS에 www.naver.com에 대한 IP주소를 요청한다

전달 받은 IP주소를 사용해서 웹 서버에 접속해서 문서 루트에 있는 정보를 요청

TCP Protocol을 이용하여 정보는 여러 홉의 네트워크를 거쳐 웹 서버로 라우팅 될 수 있도록 캡슐화 된다

사용자로부터 바로 웹서버로 전달 될수 없기 때문에 우선 컴퓨터의 게이트웨이인 유무선 공유기로 전달하려고 한다 IP주소는 네트워크 안에서 전송하는 목적으로는 사용 불가하고 MAC주소를 알아야 한다 IP 주소에 대응하는 MAC주소를 브로드 캐스팅하여 패킷을 유무선 공유기로 전달한다

전달받은 유무선 공유기는 패킷의 헤더를 보고 이 패킷이 어디로 전송되는 것인지 확인 후 자신이 속한 네트워크 어느쪽도 아닌경우 자신이 속한 라우터로 전달한다

라우터에서는 자신이 속한 네트워크로 전송되는 패킷임을 알 수 있어 웹 서버의 주소로 패킷을 전송하려고 한다 네트워크 내부의 패킷 이동은 MAC주소를 알아야 하기 때문에 같은 방법으로 MAC주소를 획득하여 전달

웹 서버는 자신에게 도달한 패킷의 헤더를 제거한후 상위 계층으로 전달 IP

웹 서버 내의 어떤 애플리케이션으로 전달해야되는지 파악후 헤더 제거 후 전달 TCP

문서 루트의 정보를 요청하는 메시지임을 파악하고 해당하는 정보를 사용자에게 전달

웹 서버로부터 정보를 받은 웹 브라우저는 이를 적절히 표현하여 사용자에게 출력

https://velog.io/@pilyeooong/%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%ED%9D%90%EB%A6%84

https://velog.io/@syleemk/HTTP-URI%EC%99%80-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9A%94%EC%B2%AD-%ED%9D%90%EB%A6%84



### CORS란 무엇인가요?

https://velog.io/@young_pallete/CORS

자원을 요청한 출처와 해당요청을 응답하는 출처가 다른경우 에 권한을 부여할 수 있게

api 호출 등

Cross Origin Resource Sharing 약자. 말 그대로 다른 도메인(스킴, 호스트, 포트가 동일한)간의 자원 공유를 의미한다. 본래 대부분의 브라우저는 타 도메인 간 요청을 Same-Origin-Policy에 의해 차단한다. 이런 설정을 우회하기 위해 여러 방법이 있었지만, HTML5가 등장하면서 CORS가 등장했다. CORS는 헤더를 통하여 Cross-Domain간 사용가능한 자원을 헤더를 통하여 알려준다.

Preflight Request : 실제 요청을 보내도 안전한지 판단하기 위해 브라우저에서 먼저 보내보는 Request. Option 메서드로 전송하여 CORS를 허용하는 지 확인한다. CORS를 지원하는 웹서버라면 사용가능한 리소스를 헤더에 담아 응답한다.

웹 클라이언트 어플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 브라우저는 요청 헤더에 `Origin`이라는 필드에 요청을 보내는 출처를 함께 담아보낸다.

`Access-Control-Allow-Origin`이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를 내려주고, 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 `Origin`과 서버가 보내준 응답의 `Access-Control-Allow-Origin`을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

https://evan-moon.github.io/2020/05/21/about-cors/



https://beomy.github.io/tech/browser/cors/

[Postman](https://www.postman.com/)으로 API를 테스트하거나, 다른 서버에서 API를 호출할 때는 멀쩡히 잘 동작하다가 브라우저에서 API를 호출할 때만 `CORS policy` 오류가 발생해서 당혹스러울 때가 있으셨을 수도 있습니다. 그 이유는 브라우저가 동일 출처 정책(Same-Origin Policy, SOP)를 지켜서 다른 출처의 리소스 접근을 금지하기 때문입니다. 하지만 실제로 웹페이지는 상당히 자주 다른 출처의 리소스를 사용해야 합니다. **예를 들어 `beomy.github.io`라는 도메인 주소를 사용하는 웹페이지에서 `beomy-api.github.io`라는 API 서버로 데이터를 요청해서 화면을 그린다면 이 웹페이지는 동일 출처 정책을 위반한 것이 됩니다.**

외부 리소스를 사용하기 위한 SOP의 예외 조항이 CORS입니다.







### 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?

https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html

HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능을 담당한다.

정적인 파일들을 담당해서 서버의 부담을 줄인다



DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server

모든걸 미리 만들어 놓고 제공할 수 없기 때문에 동적 컨텐츠 제공



### REST API에 대해서 설명해 주세요. RESTFul이란

REST란 REpresental State Transfer의 약자, 자원을 표현하여 상태를 전달한다는 뜻으로, 웹에 있는 자원을 HTTP를 통하여 직관적으로 전달하기 위한 간단한 인터페이스이다. Restful API는 대부분의 데이터를 JSON형식이나 XML형식을 담아서 HTTP 프로토콜 위에서 통신하는 API 인 것이다.
Restful 하다는 것은 REST 법칙에 통과한 것을 말하는데, 그 법칙은 다음과 같다.

1. 자원
2. 메소드(Method: GET, POST, PUT, DELETE)만으로 표현
3. 동사말고 명사만
4. 확장자는 포함하지 않음

즉 'naldo'라는 사용자를 찾는 URL 메서드를 설계할 때, Restful하다고 할 수 있는 예시는
/users/naldo (GET)
가 될 것이다.

메서드 종류 :
GET : 조회
POST : 추가
PUT : 수정
DELETE : 삭제

https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html



### API Gateway란 무엇인가요?

- https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-3API-Gateway-nvk2kf0zbj
- http://msaschool.io/operation/architecture/architecture-one/
- API Gateway는 API 서버 앞단에서 모든 API 서버들의 엔드포인트를 단일화 해주는 또다른 서버입니다. API에 대한 인증과 인가 기능을 가지고 있으며, 메세지의 내용에 따라 어플리케이션 내부에 있는 마이크로 서비스로 라우팅하는 역할을 담당합니다.

### API Gateway가 다운되면 모든 API를 사용 못할지도 모르는데, 어떤 방안을 마련해야 할까요

- https://tommypagy.tistory.com/143
- 단점으론 대다수의 서비스가 API Gateway를 통해 통신하게 되므로, API Gateway 자체에 장애가 발생하면 서비스 전체에 지장을 준다. 그래서 이를 대비하기 위한 여러가지 대안이 마련되고 있고, 그 중 최근 화두가 되고 있고,
- 가장 유명한 것은 Circuit Breaker 패턴을 기반으로 구현된 Netflix Hystrix라고 할 수 있다.
- https://elky84.github.io/2018/09/21/MSA_and_API_Gateway/



### 라우팅 방법

### Nagle Algorithm
http://egloos.zum.com/depiness/v/772710

가능하면 조금씩 여러 번 보내지 말고 한번에 많이 보내는 원칙을 기반으로 만들어진 알고리즘
TCP 소켓은 기본적으로 Nagle 알고리즘 적용
이를 끄면 네트워크 부하는 늘어나지만 작은 데이터라도 반응속도는 빨라짐



## Internet



### How does the internet work?

- TCP/IP 통신 프로토콜을 이용해 정보를 주고받는 컴퓨터 네트워크

- 브리지, 라우터, 게이트웨이
- 주요 인터넷 서비스
  - WWW, E-MAIL, HTTP, FTP 등



### 인터넷 주소 체계

MAC 주소

- 데이터 링크 층에서 사용함, 물리적으로 연결되어 있는 노드 간 프레임 전송에 사용, NIC라는 LAN 확장 카드에 하드웨어적으로 저장

IP 주소

- 네트워크 층에서 사용함, 두 개의 호스트/라우터 간 데이터그램 전달에 사용됨, 노드 to 목적지 노드, 논리 주소

포트 번호

- 두개의 프로세스간 메시지 전달에 사용되는 포트 번호, 웹 브라우저와 웹 서버 프로그램 간 연결





### IPv4 체계

네트워크 식별자 + 호스트 식별자

ex) 

호스트 식별자의 주소가 모두 0 이면 네트워크의 주소 모두 1이면 브로드캐스팅 주소

   

**NAT Network Address Translation**

사설 네트워크와 공용 인터넷을 연결하여 사용 할 수 있게 해줌, 방화벽의 핵심 기술, 공유기에 연결된 컴퓨터의 경우 내부적으로 192.168.11.0인 사설 네트워크에 있는데 라우터는 각 포트에서 데이터를 받아 NAT 매핑 규칙에 따라 IP 패킷의 발신지 IP 주소 필들르 고유한 공인 IP주소로 변환

   

**서브넷 마스크**

1에 해당하는부분이 네트워크 식별자를 의미

- 255.255.255.0의 경우 앞의 9자리가 네트워크 식별자 클래스C

   

**CIDR**

기존 클래스 기반 주소 할당을 좀더 유연하게

- 192.168.11.4/24

   

### 데이터 링크 계층, 물리 계층

   

**데이터 링크 계층**

- 물리 계층을 이용하여 네트워크 상의 주변 장치들 간의 데이터를 전송
- 주소 할당, 오류 감지

   

**캡슐화**

- 네트워크 계층 패킷에 헤더와 트레일러가 추가되는 과정

- 헤더 + L3 Data + 트레일러

   

**MAC 주소 검색**

- 다른 호스트에 패킷을 보내기 위해서 해당 호스트의  MAC주소를 알아야됨
- 이 과정을 ARP프로토콜을 이용해서 진행된다 IP주소를 통해 MAC주소를 확인
- 네트워크 내부에 브로드캐스트를 통해 ARP 요청을 한다
- 요청 시 전달되는 프레임 내 데이터 부분에 ARP 패킷이 포함되어 전달됨
- 응답을 받은 라우터는 자신의 MAC주소를 ARP패킷에 포함시켜 유니캐스트를 통해 사용자로 전달
- 이 MAC주소는 서로의 캐시에 저장된다

   

**데이터 링크 계층의 오류 검출, 정정기법**

오류 검출

오류 정정

재전송 알고리즘 ARQ



**물리계층**

   

### 라우팅 프로토콜과 IPv4 주소 이해

**네트워크 계층**

- 패킷을 송신 측에서 수신 측으로 전송하는 기능
- 전송계층으로 부터 세그먼트를 받아서 캡슐화 하고 데이터 링크 계층으로 전달
- 패킷화, 라우팅(길 찾기), 포워딩, 의사결정테이블(라우팅 테이블)

**인터네트워킹 장비**

- 허브, 리피터(신호 증폭) 물리 계층
- 브리지(2개의 LAN을 연결해주고, 통역과 포맷 등), 스위치(다중 포트 브리지 개념) 데이터 링크 계층
- 라우터(이종 네트워크 연결시 최적의 통신 경로를 찾아줌) 네트워크 계층



**라우터**

- 네트워크 트래픽을 포워딩, 최적 경로를 결정하는 장치
- 라우터 메트릭
  - 경로를 지날때 주어진 시간에 수집하는 데이터를 의미
  - 홉 횟수, MTU(Maximum Transmission Unit), 비용, 지연
- 라우팅 테이블
  - 라우터가 목적지 네트워크별 출력 인터페이스와 다음 홉 IP 주소를 저장해 놓은 데이터베이스

​      

**스위치**

- 네트워크 단위들을 연결하는 장비
- MAC 주소 학습, 필터링, 포트 미러링
- MAC 주소 테이블, 이더넷 프레임

   

**네트워크 계층 캡슐화**

- 전송계층의 세그먼트에 헤더를 추가하여 구성
- 헤더 + L4 

   

**패킷 구조**

   

**패킷 스위칭**

- 패킷의 경로를 찾는 방법으로 데이터 그램 방식, 가상 회선 방식



**네트워크 계층 프로토콜**

ARP IP주소를 이용해서 MAC주소

RARP MAC주소를 이용해서 IP주소

ICMP 네트워크 오류에 관한 정보를 전송하기 위함



**네트워크 계층 명령어**

Ping - ICMP 메시지를 이용해 네트워크 계층까지 연결성을 확인, echo request, reply

Tracert/Traceroute - 원하는 목적지까지의 경로를 출력해 주는 명령어

Route - 수동으로 라우팅 테이블의 내용을 수정

Ipconfig

Netstat - 네트워크 연결, 라우팅 테이블, 네트워크 인터페이스 등 정보

Arp - 로컬 Arp 캐쉬의 내용을 변경하거나 보여주는 명령



**라우팅 프로토콜**

- Static Routing
- Dynamic Routing

**라우팅 알고리즘**

라우터 간에 비용을 가지는 링크로 연결한 그래프 형태의 네트워크에서 출발지 라우터와 목적지 라우터 간의 최소 비용 경로를 찾는 알고리즘

출발지에서 목저지까지 가능한 모든 경로상의 링크 비용 중 최소값의 경로

- 다익스트라 알고리즘
  - 링크 상태 라우팅 알고리즘
  - 각 라우터가 전체 네트워크의 구성과 링크 상태 정보를 가지고 모든 목적지까지의 최소 비용 경로를 계산



### 다익스트라

https://m.blog.naver.com/ndb796/221234424646

1. 출발 노드를 정한다
2. 출발 노드를 기준으로 각 노드의 초소 비용을 저장
3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신
5. 반복





**IPv4 주소 할당 방식**

DHCP

- DHCP 서버를 사용해서 IP주소 및 기타 구성 세부 정보를 클라이언트에게 동적으로 제공

NAT

- 사설 네트워크에 위치하는 단말이 공용 네트워크와 통신이 가능하도록 연결시켜주는 기능
- IP주소의 부족 해결, 외부로부터 내부 주소 숨김
- NAPT - 패킷 내에 소스 포트번호를 변환, IP주소를 가지고 여러개의 내부 호스트에 접근 가능

   

### 전송계층

end to end간에 동작, TCP, UDP

UDP - 비연결 서비스, 비신뢰성, 

TCP -  연결지향 서비스, 신뢰성

- 전송한 데이터가 수신 측에서 제대로 수신하였는지 확인하기 위한 순서번호, 응답번호를 사용
- 바이트 단위로 번호
- 흐름 제어
  - 수신 한도를 넘는 과도한 패킷이 입력되지 않게 패킷의 흐름 양을 제어
  
  - 송, 수신 버퍼를 사용
  
  - 수신 TCP는 자신이 준비해 놓은 Octet 수를 지정해서 알린다 
  
    송신 TCP는 이를 참조하여 슬라이딩 윈도우 수를 조절가능
- 오류 제어
  
  - 전송 도중 발생한 부호오류를 검출, 오류 감지 및 폐기, 재전송, 중복 제거
  - checksum, 확인 응답, 재전송, 혼잡제어
- 혼잡 제어
  
  - 단위 시간당 네트워크로 전송되는 패킷의 수(부하)가 네트워크 용량을 초과하지 않게
- 느린시작 (지수적 윈도우 증가) 혼잡회피 알고리즘(혼잡이 감지될때까지 하나씩 증가)
  
   

**TCP 포트**

HTTP - TCP80

DNS 53

FTP - 21,20



**TCP 헤더 포맷**

옵션 추가시 항상 4바이트 단위에 맞게 패딩 바이트를 추가

TCP 헤더 20 바이트 IP헤더 20 바이트

응용 계층 프로그램에서 효과적인 네트워크 전송을 위해서는 적정 크기 이상의 데이터를 전송계층으로 보내야 한다

소스 포트 주소, 목적지 포트 주소, 순서번호/일련번호

확인응답 번호 ACK 번호

헤더 길이, 제어(URG, ACK, PSH, RST, SYN, FIN)

윈도 크기

checksum



### 응용 계층 기술

**HTTP 프로토콜**

- 클라이언트 서버 환경에 맞게 요청/응답 프로토콜을 구현한 것
- 웹 브라우저와 아파치 HTTP 서버 같은 웹 서버에서 HTTP 프로토콜을 구현
- 요청
  
  - 요청 메소드, URI, 프로토콜 버전, MIME형태 정보
- 응답
  - 상태 줄(status line, 성공 또는 오류 코드)

   

**HTTP  요청 메시지 정의**



**FTP 연결**

제어 연결 21번 포트, 데이터 연결 20번 포트

서버의 컨트롤 프로세스는 21번 포트를 열고 요청을 기다린다

클라이언트가 FTP 요청을 보낸다

클라이언트가 임의의 데이터 전송 프로세스 포트를 열고 요청을 기다린다

클라이언트에서 PORT명령을 통해 포트를 알려준다

서버는 클라이언트에게 받은 포트를 받고 20번 포트를 오픈한다

   

**JSP 웹 프로그래밍**

- 서버쪽의 JSP 페이지, 서블릿, JavaBeans, 컴포넌트
- 클라이언트 쪽의, HTML/그림 등 정적 문서, 애플릿, JavaScript

**JSP**

- MVC 패턴의 View에 해당하는 것
- 실행시 서블릿으로 변환되지만  XML형식으로 간단하게 기술 가능
- JSP 페이지는 서블릿을 이용하는 기능 구현과 동일한 구현이 가능

**서블릿**

- 서블릿 생명 주기를 정의하는 javax.servlet.Servlet 인터페이스
- 서블릿 초기화를 담당하는 javax.servlet.ServletConfig 인터페이스
- Http프로토콜을 통해서 동작하는 HttpServlet 클래스를 상속받아서 원하는 기능을 하는 서블릿을 구현



### DNS and how it works?

DHCP protocol로 IP를 받으면 DNS 서버 주소를 같이 받는다 보통 2개

브라우저에 www.naver.com 요청하면 먼저 로컬 DNS 에 Ip를 요청한다

없으면 DNS가 ip를 찾기위해 다른 DNS 서버들과 (DNS 메세지)통신을 시작

제일 먼저 Root DNS에 요청(전 세계 13대)

그 다음 com 도메인을 관리하는 DNS에 요청

그 다음 naver.com 도메인을 관리하는 DNS에 요청

이 DNS에는 www.naver.com에 대한 ip가 있으니 이를 전달하고 로컬 DNS는 캐싱한다

마지막 3단계를  Recursive Query 라고 한다

   

**DHCP 동작**

https://www.netmanias.com/ko/post/blog/5348/dhcp-ip-allocation-network-protocol/understanding-the-basic-operations-of-dhcp

   
























