---
title: [객체지향 설계 패턴]생성패턴2
author: HEECHANG
layout: post
---

# 생성 패턴
### MAJOR STUDY(6.18)

1. 프로토타입 패턴
- 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제 하게 된다.
- 클라이언트 응용 프로그램 코드 내에서 객체 창조자를 서브클래스 하는 것을 피하게 한다.
- clone()함수
- 런타임에 다른 객체를 생성하는 원리
- 특정 객체를 복사해야 되는 경우, 객체 생성과 내용 복사기능을 해당 객체에 맡긴다.
- client에서 구체적 Report 객체를 알 필요가 없고 새로운 Report종류가 추가되더라도 Client코드를 고칠 필요가 없다
- clone()함수가 Report를 상속받은 특정 Report의 인스턴스를 생성해서 반환해준다.
- 프로토타입 패턴과 팩토리 패턴을 같이 많이 사용한다.

```c++
//변수로 전달받는 rep타입에 따라서 해당 타입에 맞는 인스턴스가 알아서 생성된다.
//rep가 어떤 종류의 Report인지 Client는 신경쓸 필요가 없다.
CopyReport(Report *rep)
{
  Report *rep2 = rep->clone();
  //use rep2
  ...
}
```

2. 메멘토 패턴
- 객체의 상태 정보를 저장 및 복원 하는 패턴
- 객체의 내부 정보를 가지는 클래스를 따로 생성해서 관리
- 객체를 이전 상태로 되돌릴수 있는 기능을 제공하는 소프트웨어 이다.
- 상태 정보의 소유자가 아닌 객체의 접근을 막기 위해서 메멘토 객체를 만든다.
- memento객체의 생성과 내부 상태 정보의 접근은 원 소유자만 할 수 있다.
- c++ 에서는 friend키워드를 사용 friend인 소유자만 메멘토에 접근할 수 있다.(생성자와 state접근자를 private로 설정)
- memento객체의 생성이 자주 일어나거나 내부 상태정보가 많은경우 부적절
- originator가 간단해지는 장점
- 특정 언어에서는 memento객체의 내부 정보 접근을 제한하는 것이 힘들수 있다.
- 캡슐화를 통한 정보 차단은 언어의 지원이 필요
- 너무 많은 상태가 필요한경우 이전에서 변화한 부분만 memento객체에 저장

*originator*
memento객체를 생성
memento객체를 이용해서 이전 상태로 되돌린다.
1. SetMemento(Memento m); m-> GetState()
2. CreateMemento();  new Memento

*caretaker*
memento객체들을 보관하거나 관리한다.
memento객체를 생성하거나 내부정보에 접근할 수 없다.

*memento*
객체의 상태 정보를 저장한다.
객체 이외의 다른 객체에서 접근을 차단한다.
1. GetState();
2. SetState();

```java
class Originator {
    private String state;
    // The class could also contain additional data that is not part of the
    // state saved in the memento..

    public void set(String state) {
        this.state = state;
        System.out.println("Originator: Setting state to " + state);
    }

    public Memento saveToMemento() {
        System.out.println("Originator: Saving to Memento.");
        return new Memento(this.state);
    }

    public void restoreFromMemento(Memento memento) {
        this.state = memento.getSavedState();
        System.out.println("Originator: State after restoring from Memento: " + state);
    }

    public static class Memento {
        private final String state;

        public Memento(String stateToSave) {
            state = stateToSave;
        }

        // accessible by outer class only
        private String getSavedState() {
            return state;
        }
    }
}

class Caretaker {
    public static void main(String[] args) {
        List<Originator.Memento> savedStates = new ArrayList<Originator.Memento>();

        Originator originator = new Originator();
        originator.set("State1");
        originator.set("State2");
        savedStates.add(originator.saveToMemento());
        originator.set("State3");
        // We can request multiple mementos, and choose which one to roll back to.
        savedStates.add(originator.saveToMemento());
        originator.set("State4");

        originator.restoreFromMemento(savedStates.get(1));
    }
}
```
