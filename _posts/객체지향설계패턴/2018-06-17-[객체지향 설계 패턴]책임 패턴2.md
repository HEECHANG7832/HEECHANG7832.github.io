---
title: [객체지향 설계 패턴]책임패턴2
author: HEECHANG
layout: post
---

# 책임 패턴
### MAJOR STUDY(6.17)

*객체는 자신의 데이터 및 자신의 동작에만 책임을 가진다*

1. 프록시 패턴
- 자원소모가 큰 작업을 꼭 필요한 순간에만 사용하도록 중간에 프록시를 둔다.
- 시간이 많이 소요되는 객체를 생성하는 데신에 간단한 객체로 대체한다.

*Proxy*
Real에 대한 레퍼런스를 유지하고 Real객체와 동일한 인터페이스를 구현하여 Real을 대신할 수 있다. 해당 객체의 생성까지 책임질수도 있다.

```JAVA
interface Image {
      public void displayImage();
}
//on System A
 8 class RealImage implements Image {
 9     private String filename;
10     public RealImage(String filename) {
11         this.filename = filename;
12         loadImageFromDisk();
13     }
14
15     private void loadImageFromDisk() {
16         System.out.println("Loading   " + filename);
17     }
18
19     @Override
20     public void displayImage() {
21         System.out.println("Displaying " + filename);
22     }
23 }
24
25 //on System B
26 class ProxyImage implements Image {
27     private String filename;
28     private Image image;
29
30     public ProxyImage(String filename) {
31         this.filename = filename;
32     }
33     
34     @Override
35     public void displayImage() {
36         if (image == null)
37            image = new RealImage(filename);
38
39         image.displayImage();
40     }
41 }
42
43 class ProxyExample {
44     public static void main(String[] args) {
45         Image image1 = new ProxyImage("HiRes_10MB_Photo1");
46         Image image2 = new ProxyImage("HiRes_10MB_Photo2");
47
48         image1.displayImage(); // loading necessary
49         image2.displayImage(); // loading necessary
50     }
51 }
```

**프록시 종류**

- 리모트 프록시
  Client가 Real 또는 Proxy의 메서드를 사용할때 Subject로부터 상속받은 동일한 메서드를 사용하는 패턴이다.
  Client가 Subject가 Real인지 Proxy인지 신경쓸 필요가 없다.
- 가상 프록시
  언제나 메모리에 올라갈 필요가 없는 객체에 대해 필요할때 생성한다.
- 보호 프록시
  Subject를 상속받아 Proxy와 Real이 만들어지지만 Real에 대한 접근을 제어할때 사용한다.
- 스마트 레퍼런스
  Real에 접근할때 추가적인 행동을 수행
  잠조 횟수, 잠금(수정불가) 등

이득
  *최적화, 투명성*

2. 책임 체인 패턴
- 명령 객체와 일련의 처리 객체를 포함하는 디자인 패턴
- 각각의 처리 객체는 명령 객체를 처리할 수 있다.
- 자신이 처리하지 못하는 명령은 다음 처리 객체로 넘어간다
- 체인의 끝까지 진행된다.
- 결합을 느슨하게 할 수 있다.
- 요청을 보내는 객체와 처리하는 객체를 분리
- 요청하는 쪽는 받는쪽의 참조를 모두 가지고 있을 필요가 없다
- 연결고리 중간에 동적으로 삽입 삭제 가능
- 요청이 여러개인 경우 각 요청에 대해서 개별적인 함수를 구현하고
  handleRequest()함수의 인자로 넘긴다.
- JAVA에서 try-catch-finally문

```JAVA
abstract class PurchasePower {
    protected final double base = 500;
    protected PurchasePower successor;

    public void setSuccessor(PurchasePower successor) {
        this.successor = successor;
    }

    abstract public void processRequest(PurchaseRequest request);
}

class ManagerPower extends PurchasePower {
    private final double ALLOWABLE = 10 * base;

    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() < ALLOWABLE) {
            System.out.println("Manager will approve $" + request.getAmount());
        } else if (successor != null) {
            successor.processRequest(request);
        }
    }
}

class DirectorPPower extends PurchasePower {
    private final double ALLOWABLE = 20 * base;

    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() < ALLOWABLE) {
            System.out.println("Director will approve $" + request.getAmount());
        } else if (successor != null) {
            successor.processRequest(request);
        }
    }
}

class VicePresidentPPower extends PurchasePower {
    private final double ALLOWABLE = 40 * base;

    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() < ALLOWABLE) {
            System.out.println("Vice President will approve $" + request.getAmount());
        } else if (successor != null) {
            successor.processRequest(request);
        }
    }
}

class PresidentPPower extends PurchasePower {
    private final double ALLOWABLE = 60 * base;

    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() < ALLOWABLE) {
            System.out.println("President will approve $" + request.getAmount());
        } else {
            System.out.println( "Your request for $" + request.getAmount() + " needs a board meeting!");
        }
    }
}

The PurchaseRequest class with its Getter methods which keeps the request data in this example.
class PurchaseRequest {
    private int number;
    private double amount;
    private String purpose;

    public PurchaseRequest(int number, double amount, String purpose) {
        this.number = number;
        this.amount = amount;
        this.purpose = purpose;
    }

    public double getAmount() {
        return amount;
    }
    public void setAmount(double amt)  {
        amount = amt;
    }

    public String getPurpose() {
        return purpose;
    }
    public void setPurpose(String reason) {
        purpose = reason;
    }

    public int getNumber(){
        return number;
    }
    public void setNumber(int num) {
        number = num;
    }
}
class CheckAuthority {
    public static void main(String[] args) {
        ManagerPPower manager = new ManagerPPower();
        DirectorPPower director = new DirectorPPower();
        VicePresidentPPower vp = new VicePresidentPPower();
        PresidentPPower president = new PresidentPPower();
        manager.setSuccessor(director);
        director.setSuccessor(vp);
        vp.setSuccessor(president);

        // Press Ctrl+C to end.
        try {
            while (true) {
                System.out.println("Enter the amount to check who should approve your expenditure.");
                System.out.print(">");
                double d = Double.parseDouble(new BufferedReader(new InputStreamReader(System.in)).readLine());
                manager.processRequest(new PurchaseRequest(0, d, "General"));
           }
        } catch(Exception e) {
            System.exit(1);
        }
    }
}
```

3. 플라이웨이트 패턴
- 동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화 하는 디자인 페턴
- 공통으로 사용하는 객체는 계속 새로 생성하지 않고 공유를 통해 효율적으로 자원을 활용한다.
- 한번 생성된 객체는 두번 생성하지 않고 폴에 의해서 관리한다.
- 게임 같은 경우 내부에 많은 UI나 컴포넌트 들이 있는데 이 경우 리소스를 여러 객체에서 공유해서 사용하는 방식을 적용한다.
- JAVA에서 String pool에서도 이 패턴을 사용한다.

```JAVA

```
