---
title: [객체지향 설계 패턴]책임패턴1
author: HEECHANG
layout: post
---

# 책임 패턴
### MAJOR STUDY(6.17)

1. 싱글톤 패턴
 - 싱글톤 패턴은 단일 스레드에 사용되고 더블 체크 로킹 패턴은 다중 스레드에서 사용된다. 두 패턴 모두 클래스에 오직 하나의 객체만이 생성됨을 보장한다.
 - 하나만 사용되어야 하는 객체를 만들때 사용
 - 객체가 이미 인스턴스화 되어있는지 검사하고 그렇지 않다면 객체를 만들고 그 참조를 반환한다.
 - 생성자는 protect 또는 private로 선언

*적용방법*
자기자신의 변수를 private static으로 선언한다.
생성자를 private로 변경한다.
자기자신의 변수에 접근하는 메소드를 정의한다 (getter)

```java
public class Singleton {

    private static Singleton singleton = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        //필요할때에 생성하도록 해줄수 있다.
        /*
        if(singleton == null){
            singleton = new Singleton();
        }*/
        return singleton;
    }
}
```

*더블체크 락킹 패턴*
다중 스레드에서 싱글톤 패턴에 동시에 instance를 요구할때 발생하는 문제를 해결하기 위한 패턴

```java
public static synchronized Singleton getInstance() {
       if (instance == null) {
           instance = new Singleton();
       }
       return instance ;
   }
```
이런식으로 동기화 문제를 해결할 수 있지만 이는 Overhead가 발생 *synchronized*

그래서
```java
public class Singleton {

    private volatile static Singleton singleton;
    private Singleton(){}

    public static Singleton getInstance(){
        if(singleton == null){
            synchronized (Singleton.class) {
              if(singleton == null) //더욱 완벽한 동작을 위해
                singleton = new Singleton();
            }
        }
        return singleton;
    }
}
```
이런식으로 해결할 수 있다.

2. 옵저버 패턴
- 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
- 분산 이벤트 핸들링 시스템을 구현하는데 사용
- 옵저버 혹은 리스너라고 불리는 객체를 관찰대상(Subject)에 등록시킨다
- 관찰대상(Subject)는 이벤트를 발생시키는 주체이다. 옵저버를 register 또는 unregister한다.
- 이벤트가 발생하면 각 옵저버는 *callback* 을 받는다.
- 옵저버들의 notify()를 각각 구현하면서 callback을 받았을때 행동을 정의한다.

특징
- Subject는 옵저버의 리스트만 알고 있고 옵저버 코드의 변경이 Subject에 영향을 미치지 않는다.
- 옵저버가 많다면 해시 태이블을 사용
- 많은 Subject로부터 이벤트를 받는다면?
   java에 Observable클래스에 정의 된것 처럼 notifyObserver(Object o, 변수) 에서 Subject를 넘겨준다.

*구현*
```java
public interface Subject {
     void registerobserver(Observer observer);
     void removeObserver(Observer observer);
     void notifyObservers();
}

public interface Observer {
     void update();
}
```

자바에서는 Subject에 Observable클래스를 상속받고 Observer에 Observer클래스를 상속받아 옵저버 패턴을 간다한게 구현할 수 있다.

*Subject*
Observable
1. addObserver()
2. deleteObserver()
3. notifyObservers()
```java
public class EventSource extends Observable implements Runnable
{
   public void run()
   {
       try
       {
           final InputStreamReader isr = new InputStreamReader( System.in );
           final BufferedReader br = new BufferedReader( isr );
           while( true )
           {
               final String response = br.readLine();
               setChanged();
               notifyObservers( response );
               /*
               for observer in observerCollection
                call observer.update()
               */
           }
       }
       catch (IOException e)
       {
           e.printStackTrace();
       }
   }
}
```

*Observer*
Observer
1. update()
```java
public class ResponseHandler implements Observer
{
    private String resp;
    //Subject를 전달받기때문에 어떤 관찰대상이 보낸 이벤트인지 구분할 수 있다.
    public void update (Observable obj, Object arg)
    {
        if (arg instanceof String)
        {
            resp = (String) arg;
            System.out.println("\nReceived Response: "+ resp );
        }
    }
}
```

*등록 및 실행*
```java
        evSrc.addObserver( respHandler );

        // 이벤트를 발행시키는 쓰레드 시작
        Thread thread = new Thread(evSrc);
        thread.start();
```

Observable이 클래스로 정의되어있기 때문에 다중상속이 안되는 java에서는 불편할 수 있다.

3. 중재자 패턴
- 객체들이 어떻게 상호작용하는지를 함축해놓은 객체
- 객체간 통신은 중재자 객체 안에 함축된다.
- 객체들은 더이상 상호간에 통신을 직접 하지 않는다.
- 이를 통해 결합도를 낮출 수 있다.
- 각 객체들은 중재자 객체말고 다른 객체는 모른다.
- M:N 관계를 M:1로 변경하는 것
- 새로운 부품이 추가될 때 중재자 객체만 수정하면 된다.
- *중재자를 Subject로 협력자를 Observer로 생각하면 옵저버 패턴과 비슷하다*
- 중재자 객체가 복잡해질수 있다. (위키에 예시를 보면 일관되지 않은 Colleague를 3개나 가지는 중재자 객체가 등록과 사용 각각 두개의 메서드를 가지면서 총6개의 메서드를 만들게 된다)
객체들끼리 서로를 직접 참조하는것을 피한다
상호작용이 복잡하고 서로의 의존관계 파악이 힘들때 사용
다른 객체를 많이 참조하고 있어 재사용이 어려울때 사용


*중재자*
Mediator
```java
//굳이 필요없다
interface Mediator {
  void register(Colleague a);
  void sendMessage(String name, String event);
}

class ConcreteMediator implements Mediator {
        private List<Colleague> colleagues = new ArrayList<>();

        public Mediator() {
        }

        public void register(Colleague a) {
                colleagues.add(a);
                a.setMediator(this);
        }

        @Override
        public void sendMessage() {
            //특정 동작
        }
}
```

*협력자*
Colleague
```java
interface Colleague {
    void excute();
}

//A concrete colleague
class ConcreteColleague implements Colleague {

    Mediator med;

    BtnBook(Mediator m) {
        med = m;
        med.register(this);
    }

    public void excute() {
        med.sendMessage();
    }

}
```
